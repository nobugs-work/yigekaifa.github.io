{"meta":{"title":"一个开发","subtitle":"不够精彩的生活和工作也需要记录一下","description":"一个开发的自留地，虽然我不经常写什么东西，但是只是做个记录用","author":"一个开发","url":"https://yigekaifa.com","root":"/"},"pages":[{"title":"关于","date":"2020-03-10T14:43:04.000Z","updated":"2020-03-10T22:22:03.266Z","comments":true,"path":"about/index.html","permalink":"https://yigekaifa.com/about/index.html","excerpt":"","text":"一个开发， 把之前的文章都删除了，重新开始写。"},{"title":"分类","date":"2020-03-10T17:23:57.000Z","updated":"2020-03-10T17:28:18.837Z","comments":true,"path":"categories/index.html","permalink":"https://yigekaifa.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-10T17:22:20.000Z","updated":"2020-03-10T17:28:08.427Z","comments":true,"path":"tags/index.html","permalink":"https://yigekaifa.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如果我死了","slug":"if-i-dead","date":"2020-03-10T22:22:26.000Z","updated":"2020-03-11T00:24:40.863Z","comments":true,"path":"if-i-dead/","link":"","permalink":"https://yigekaifa.com/if-i-dead/","excerpt":"2020年3月11日 早 6：00","text":"2020年3月11日 早 6：00 昨晚没睡，但这不重要。问题是我丝毫没有瞌睡的感觉，而且我昨天没喝咖啡。 所以啊，如果有一天我猝死了，我不希望有新闻带上我的职业。就写一男子猝死就行了。 另外是不是人死之前都会写一些奇怪的东西…这些都不知道为什么想出来的，我现在也不想写奇怪的东西。我想写一下简历，然后收拾一下垃圾。","categories":[{"name":"Think","slug":"Think","permalink":"https://yigekaifa.com/categories/Think/"}],"tags":[{"name":"熬夜","slug":"熬夜","permalink":"https://yigekaifa.com/tags/%E7%86%AC%E5%A4%9C/"},{"name":"随想","slug":"随想","permalink":"https://yigekaifa.com/tags/%E9%9A%8F%E6%83%B3/"},{"name":"照片","slug":"照片","permalink":"https://yigekaifa.com/tags/%E7%85%A7%E7%89%87/"}]},{"title":"PowerShell禁止执行脚本的解决方法","slug":"script-cant-run-on-powershell","date":"2020-03-10T18:26:23.000Z","updated":"2020-03-10T19:34:14.407Z","comments":true,"path":"script-cant-run-on-powershell/","link":"","permalink":"https://yigekaifa.com/script-cant-run-on-powershell/","excerpt":"如果出现类似下面的提示： 无法加载文件 ******.xxx，因为在此系统中禁止执行脚本。有关详细信息，请参阅 \"get-help about_signing\"。所在位置 行:1 字符: 17 解决方法：","text":"如果出现类似下面的提示： 无法加载文件 ******.xxx，因为在此系统中禁止执行脚本。有关详细信息，请参阅 \"get-help about_signing\"。所在位置 行:1 字符: 17 解决方法： 运行Get-ExecutionPolicy。如果返回Restricted，然后运行set-ExecutionPolicy RemoteSigned 然后就可以运行命令了。 另外如果还不能执行，例如你npm安装的一些命令不能运行，那么请你把C:\\Users\\用户名\\AppData\\Roaming\\npm添加到系统变量Path里面。","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://yigekaifa.com/tags/PowerShell/"},{"name":"Script","slug":"Script","permalink":"https://yigekaifa.com/tags/Script/"}]},{"title":"Linux下DD命令进度查看","slug":"dd-cmd-on-linux","date":"2020-03-10T18:25:06.000Z","updated":"2020-03-10T19:34:02.935Z","comments":true,"path":"dd-cmd-on-linux/","link":"","permalink":"https://yigekaifa.com/dd-cmd-on-linux/","excerpt":"在Ubuntu 系统上执行如下命令 dd if=/img.iso of=/dev/mydevice bs=10M count=100000","text":"在Ubuntu 系统上执行如下命令 dd if=/img.iso of=/dev/mydevice bs=10M count=100000 有的时候，可能会非常耗时，这个时候，如果让dd命令输出执行进度信息，会非常有用。 重新打开一个Shell，然后执行如下命令即可每秒输出一次进度信息 watch -n 1 pkill -USR1 -x dd","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yigekaifa.com/tags/Linux/"},{"name":"cmd","slug":"cmd","permalink":"https://yigekaifa.com/tags/cmd/"}]},{"title":"自带清除内容功能的EditText","slug":"edittext-with-clear-icon","date":"2020-03-10T18:23:58.000Z","updated":"2020-03-10T21:55:01.723Z","comments":true,"path":"edittext-with-clear-icon/","link":"","permalink":"https://yigekaifa.com/edittext-with-clear-icon/","excerpt":"出发需求： 减少手写清除EditText内容的代码 xml里面写的话，点击清除按钮会失去焦点，然后软键盘消失，需要重复点击输入框才可以继续输入","text":"出发需求： 减少手写清除EditText内容的代码 xml里面写的话，点击清除按钮会失去焦点，然后软键盘消失，需要重复点击输入框才可以继续输入 public class ClearEditText extends AppCompatEditText implements View.OnFocusChangeListener, View.OnTouchListener, TextWatcher &#123; private Drawable mClearTextIcon; private OnFocusChangeListener mOnFocusChangeListener; private OnTouchListener mOnTouchListener; private boolean isShowClearIcon; public ClearEditText(Context context) &#123; super(context); init(context, null); &#125; public ClearEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public ClearEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; mClearTextIcon = getCompoundDrawables()[2]; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ClearEditText); isShowClearIcon = typedArray.getBoolean(R.styleable.ClearEditText_isShowClearIcon, true); if (mClearTextIcon == null) &#123; final Drawable drawable = ContextCompat.getDrawable(context, R.mipmap.icon_clear_text); final Drawable wrapDrawable = DrawableCompat.wrap(drawable); DrawableCompat.setTint(wrapDrawable, getCurrentHintTextColor()); mClearTextIcon = wrapDrawable; &#125; mClearTextIcon.setBounds(0, 0, mClearTextIcon.getIntrinsicHeight(), mClearTextIcon.getIntrinsicHeight()); setClearIconVisible(false); super.setOnFocusChangeListener(this); super.setOnTouchListener(this); addTextChangedListener(this); &#125; public void setmOnFocusChangeListener(OnFocusChangeListener mOnFocusChangeListener) &#123; this.mOnFocusChangeListener = mOnFocusChangeListener; &#125; public void setmOnTouchListener(OnTouchListener mOnTouchListener) &#123; this.mOnTouchListener = mOnTouchListener; &#125; private void setClearIconVisible(boolean visible) &#123; mClearTextIcon.setVisible(visible &amp;&amp; isShowClearIcon, false); final Drawable[] compoundDrawables = getCompoundDrawables(); setCompoundDrawables( compoundDrawables[0], compoundDrawables[1], visible ? mClearTextIcon : null, compoundDrawables[3]); &#125; @Override public void onFocusChange(View v, boolean hasFocus) &#123; if (hasFocus) &#123; setClearIconVisible(getText().length() &gt; 0); &#125; else &#123; setClearIconVisible(false); &#125; if (mOnFocusChangeListener != null) &#123; mOnFocusChangeListener.onFocusChange(v, hasFocus); &#125; &#125; @Override public boolean onTouch(View v, MotionEvent motionEvent) &#123; int x = (int) motionEvent.getX(); if (mClearTextIcon.isVisible() &amp;&amp; x &gt; getWidth() - getPaddingRight() - mClearTextIcon.getIntrinsicWidth()) &#123; if (motionEvent.getAction() == motionEvent.ACTION_UP) &#123; setError(null); setText(\"\"); &#125; return true; &#125; return (mOnTouchListener != null &amp;&amp; mOnTouchListener.onTouch(v, motionEvent)); &#125; public void isShowClearIcon(boolean isShowClearIcon) &#123; this.isShowClearIcon = isShowClearIcon; setClearIconVisible(getText().length() &gt; 0); &#125; @Override public void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; if (isFocused()) &#123; setClearIconVisible(text.length() &gt; 0); &#125; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125; attrs： &lt;declare-styleable name=\"ClearEditText\"&gt; &lt;!--是否需要展示清除按钮--&gt; &lt;attr name=\"isShowClearIcon\" format=\"boolean\"/&gt;&lt;/declare-styleable&gt; 使用 &lt;xxx.ClearEditText&gt; &lt;!--some parms here--&gt; ... &lt;!--set is show the icon here--&gt; app:isShowClearIcon = \"true\"&lt;/ClearEditText&gt; 或者在java代码中: clearTextView.isShowClearIcon(true);","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Edittext","slug":"Edittext","permalink":"https://yigekaifa.com/tags/Edittext/"},{"name":"Custom","slug":"Custom","permalink":"https://yigekaifa.com/tags/Custom/"}]},{"title":"监听布局内所有的EditText","slug":"listen-all-edittext-in-your-layout","date":"2020-03-10T15:49:23.000Z","updated":"2020-03-10T18:15:58.298Z","comments":true,"path":"listen-all-edittext-in-your-layout/","link":"","permalink":"https://yigekaifa.com/listen-all-edittext-in-your-layout/","excerpt":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步的控件，你可以试试下面这个控件。","text":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步的控件，你可以试试下面这个控件。 1. 获取子view编历布局，看当前布局有几个EditText,然后去监听拿到focus的view 获取子view的方式： // 遍历viewGroup public int traverseViewGroup(View view) &#123; int viewCount = 0; if (null == view) &#123; return 0; &#125; if (view instanceof ViewGroup) &#123; //遍历ViewGroup,是子view加1，是ViewGroup递归调用 for (int i = 0; i &lt; ((ViewGroup) view).getChildCount(); i++) &#123; View child = ((ViewGroup) view).getChildAt(i); if (child instanceof ViewGroup) &#123; viewCount += traverseViewGroup(((ViewGroup) view).getChildAt(i)); &#125; else &#123; viewCount++; &#125; &#125; &#125; else &#123; viewCount++; &#125; return viewCount; &#125; 非递归方法获取子view： // 遍历viewGroup public int traverseViewGroup(View view) &#123; int viewCount = 0; if (null == view) &#123; return 0; &#125; if (view instanceof ViewGroup) &#123; ViewGroup viewGroup = (ViewGroup) view; LinkedList&lt;ViewGroup&gt; linkedList = new LinkedList&lt;&gt;(); linkedList.add(viewGroup); while (!linkedList.isEmpty()) &#123; //removeFirst()删除第一个元素，并返回该元素 ViewGroup current = linkedList.removeFirst(); viewCount++; //遍历linkedList中第一个viewGroup中的子view for (int i = 0; i &lt; current.getChildCount(); i++) &#123; if (current.getChildAt(i) instanceof ViewGroup) &#123; linkedList.addLast((ViewGroup) current.getChildAt(i)); &#125; else &#123; viewCount++; &#125; &#125; &#125; &#125; else &#123; viewCount++; &#125; return viewCount; &#125; 获取到子view的时候，你需要判断这个子view是不是EditText，方法有两种： v.getClassName() == \"EditText\" v instanceof Button 2. 拿到子view之后：方法1. 拿到子view之后，不需要每个都去监听（当然你也可以这么做），另外一种，判断在viewgroup中哪个子view获取到了焦点，然后给他添加监听，其他的移除监听。 然后给设置的按钮去设置enable 方法2. LiveData监听数据变化，但是和上面的方式换汤不换药，代码量更多了一点。LiveData的具体使用可以参考： https://developer.android.google.cn/reference/android/arch/lifecycle/LiveData 需要完成的内容： 添加例外的参数，例如非必填的Edittext","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Edittext","slug":"Edittext","permalink":"https://yigekaifa.com/tags/Edittext/"},{"name":"ViewGroup","slug":"ViewGroup","permalink":"https://yigekaifa.com/tags/ViewGroup/"},{"name":"CustomView","slug":"CustomView","permalink":"https://yigekaifa.com/tags/CustomView/"}]},{"title":"startWithPop()出现两个Fragment都退出的情况","slug":"startwithpop-close-both-fragment","date":"2020-03-10T15:37:18.000Z","updated":"2020-03-10T19:34:18.671Z","comments":true,"path":"startwithpop-close-both-fragment/","link":"","permalink":"https://yigekaifa.com/startwithpop-close-both-fragment/","excerpt":"有时候startWithPop()会出现两个Fragment都出栈的情况，一般当前fragment是RootView的时候会出现这个情况。","text":"有时候startWithPop()会出现两个Fragment都出栈的情况，一般当前fragment是RootView的时候会出现这个情况。 解决方法： ((BaseFragment) getParentFragment()).start(toFragment); 或者 popTo(A.class,true,new Runnable()&#123; @Override public void run() &#123; start(B); &#125;&#125;,getFragmentAnimator().getPopExit()); // getFragmentAnimator().getPopExit() 代表popTo时的动画","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"startWithPop","slug":"startWithPop","permalink":"https://yigekaifa.com/tags/startWithPop/"},{"name":"Fragment","slug":"Fragment","permalink":"https://yigekaifa.com/tags/Fragment/"}]},{"title":"TabLayout的简单修改","slug":"some-changes-for-tablayout","date":"2020-03-10T15:11:19.000Z","updated":"2020-03-10T15:13:14.895Z","comments":true,"path":"some-changes-for-tablayout/","link":"","permalink":"https://yigekaifa.com/some-changes-for-tablayout/","excerpt":"设计稿上的tab布局我用了design库的tablayout，根据设计上的图来看，选中的tab要是粗体，下方横线等宽于字体。","text":"设计稿上的tab布局我用了design库的tablayout，根据设计上的图来看，选中的tab要是粗体，下方横线等宽于字体。 问题1：TabLayout无法控制当前选中的行的字体解决方案：setCustomView() 。 首先写一个方法，用来返回每个tab的view： public View getTabView(int position, String title) &#123; View view = LayoutInflater.from(getContext()).inflate(R.layout.tab_item, null); TextView txt_title = (TextView) view.findViewById(R.id.textView); txt_title.setText(title); return view;&#125; 然后把view设置到tablayout中： tabLayout.getTabAt(0).setCustomView(getTabView(0, \"全部\")); 然后去选择控制tablayout的标签的样式，我是新建了一个OnTabSelectedListener，然后再里面进行设置的 OnTabSelectedListener onTabSelectedListener = new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // 选中的tab设置为粗体 TextView textView = tabLayout.getTabAt(tab.getPosition()).getCustomView().findViewById(R.id.textView); textView.setTypeface(null, Typeface.BOLD); viewPager.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; // 未选中的tab设置为正常 TextView textView = tabLayout.getTabAt(tab.getPosition()).getCustomView().findViewById(R.id.textView); textView.setTypeface(null, Typeface.NORMAL); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;; 但是，设置好之后出现了新的问题： 问题2：下面Indicator宽度始终为最宽的宽度即使你设置了app:tabIndicatorFullWidth=&quot;true&quot;，因为tabIndicatorFullWidth是根据默认布局的文字宽度来设置的，我们自定义布局之后，系统无法获取到文字大小和长度，所以就会设置成最宽的宽度。 我的解决方法： public void reflex(final TabLayout tabLayout) &#123; tabLayout.post(new Runnable() &#123; @Override public void run() &#123; try &#123; LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0); for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123; View tabView = mTabStrip.getChildAt(i); Field mTextViewField = tabView.getClass().getDeclaredField(\"textView\"); mTextViewField.setAccessible(true); TextView mTextView = (TextView) mTextViewField.get(tabView); tabView.setPadding(0, 0, 0, 0); int width = 0; width = mTextView.getWidth(); if (width == 0) &#123; mTextView.measure(0, 0); width = mTextView.getMeasuredWidth(); &#125; LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams(); params.width = width; WindowManager wm1 = ((Activity) getContext()).getWindowManager(); int width1 = wm1.getDefaultDisplay().getWidth(); LogUtils.d(\"\" + width1 / tabLayout.getTabCount() + \"=============\" + mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)); params.leftMargin = (width1 / tabLayout.getTabCount() - mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)) / 2; params.rightMargin = (width1 / tabLayout.getTabCount() - mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)) / 2; tabView.setLayoutParams(params); tabView.invalidate(); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; public static int dip2px(Context context, float dpValue) &#123; float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; reflex(tabLayout);调用在所有getTabAt方法之后即可解决这个，但是还有点小问题，tab大小被设置成了文字宽度…这个问题暂时保留，下次解决。另外有几个小问题 去掉tab的水波纹效果，无论是support还是AdnroidX，都用app:tabRippleColor=&quot;@android:color/transparent&quot;，app:tabBackground=&quot;@android:color/transparent&quot;即使在support下也无效","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"TabLayout","slug":"TabLayout","permalink":"https://yigekaifa.com/tags/TabLayout/"},{"name":"widget","slug":"widget","permalink":"https://yigekaifa.com/tags/widget/"},{"name":"custom","slug":"custom","permalink":"https://yigekaifa.com/tags/custom/"}]},{"title":"Android中几种定位方式的粗解","slug":"some-way-to-get-location","date":"2020-03-10T14:46:16.000Z","updated":"2020-03-11T00:21:48.471Z","comments":true,"path":"some-way-to-get-location/","link":"","permalink":"https://yigekaifa.com/some-way-to-get-location/","excerpt":"之前朋友问我Tiktok为什么禁用了定位，开启了全局代理，还是可以获取到位置。当时想法只有一个：基站定位。我让他在设置里关掉移动服务（关闭手机卡）之后，确实可以正常使用了。 这里简单说一下Android中集中定位方式。","text":"之前朋友问我Tiktok为什么禁用了定位，开启了全局代理，还是可以获取到位置。当时想法只有一个：基站定位。我让他在设置里关掉移动服务（关闭手机卡）之后，确实可以正常使用了。 这里简单说一下Android中集中定位方式。 这里是在Android10添加的新权限，在后台获取位置：https://developer.android.com/reference/android/Manifest.permission.html#ACCESS_BACKGROUND_LOCATION 1. GPS权限（注意版本变化）： &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt; 具体定位代码 var locManager = getSystemService(Context.LOCATION_SERVICE) as LocationManagervar loc = locManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)if(loc != null)&#123; Log.e(\"gpslocation\", loc.toString()) toast(loc.toString())&#125;locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0F, object : LocationListener&#123; override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) &#123; &#125; override fun onProviderEnabled(provider: String?) &#123; &#125; override fun onProviderDisabled(provider: String?) &#123; &#125; override fun onLocationChanged(location: Location?) &#123; Log.e(\"gpslocation\", location.toString()) toast(location.toString()) &#125;&#125;) 2. Network获取位置与GPS定位相同，代码都一样。只是申请权限不同。并且在室内时，GPS需要一定时间来定位，而Network在网络状况不好时不可用。 3. IPAPP通过对当前IP的分析，可以得到你大致的位置。一般不采用这种方案，IP太容易被伪装。 4. WiFi（WLAN）定位需要权限： &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; 这个也比较简单，就是过程就是拿到当前的WiFi信息，然后通过mac地址（BSSID）进行查询。具体查询的接口可以去聚合数据搜索一下，这里不再多说。 5. 基站定位这个要稍微说一下。在你关闭了所有定位传感器之后，如果你的手机还是处于有服务的状态下，就可以进行大概定位。通过TelephonyManager获取当前手机信号的基站信息。可以定位到大概区以下的位置。 MCC，Mobile Country Code，移动国家代码（中国的为460）MNC，Mobile Network Code，移动网络号码（中国移动为00，中国联通为01）LAC，Location Area Code，位置区域码CID，Cell Identity，基站编号，是个16位的数据（范围是0到65535） 看似类型繁多，但是实际用起来用处不是很多。建议大家还是用第三方定位库吧，简单精准还好用。 参考文章 https://developer.android.com/guide/topics/location/strategies","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yigekaifa.com/tags/Android/"},{"name":"Location","slug":"Location","permalink":"https://yigekaifa.com/tags/Location/"},{"name":"定位","slug":"定位","permalink":"https://yigekaifa.com/tags/%E5%AE%9A%E4%BD%8D/"}]}]}
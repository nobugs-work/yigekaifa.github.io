{"meta":{"title":"一个开发","subtitle":"不够精彩的生活和工作也需要记录一下","description":"一个开发的自留地，虽然我不经常写什么东西，但是只是做个记录用","author":"一个开发","url":"https://yigekaifa.com","root":"/"},"pages":[{"title":"关于","date":"2020-03-10T14:43:04.000Z","updated":"2020-03-10T17:29:49.883Z","comments":true,"path":"about/index.html","permalink":"https://yigekaifa.com/about/index.html","excerpt":"","text":"一个开发，一个开发。"},{"title":"分类","date":"2020-03-10T17:23:57.000Z","updated":"2020-03-10T17:28:18.837Z","comments":true,"path":"categories/index.html","permalink":"https://yigekaifa.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-10T17:22:20.000Z","updated":"2020-03-10T17:28:08.427Z","comments":true,"path":"tags/index.html","permalink":"https://yigekaifa.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-03-10T20:57:50.478Z","updated":"2020-03-10T20:57:50.478Z","comments":true,"path":"hello-world/","link":"","permalink":"https://yigekaifa.com/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"PowerShell禁止执行脚本的解决方法","slug":"script-cant-run-on-powershell","date":"2020-03-10T18:26:23.000Z","updated":"2020-03-10T19:34:14.407Z","comments":true,"path":"script-cant-run-on-powershell/","link":"","permalink":"https://yigekaifa.com/script-cant-run-on-powershell/","excerpt":"如果出现类似下面的提示： 无法加载文件 ******.xxx，因为在此系统中禁止执行脚本。有关详细信息，请参阅 &quot;get-help about_signing&quot;。 所在位置 行:1 字符: 17 解决方法：","text":"如果出现类似下面的提示： 无法加载文件 ******.xxx，因为在此系统中禁止执行脚本。有关详细信息，请参阅 &quot;get-help about_signing&quot;。 所在位置 行:1 字符: 17 解决方法： 运行Get-ExecutionPolicy。如果返回Restricted，然后运行set-ExecutionPolicy RemoteSigned 然后就可以运行命令了。 另外如果还不能执行，例如你npm安装的一些命令不能运行，那么请你把C:\\Users\\用户名\\AppData\\Roaming\\npm添加到系统变量Path里面。","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://yigekaifa.com/tags/PowerShell/"},{"name":"Script","slug":"Script","permalink":"https://yigekaifa.com/tags/Script/"}]},{"title":"Linux下DD命令进度查看","slug":"dd-cmd-on-linux","date":"2020-03-10T18:25:06.000Z","updated":"2020-03-10T19:34:02.935Z","comments":true,"path":"dd-cmd-on-linux/","link":"","permalink":"https://yigekaifa.com/dd-cmd-on-linux/","excerpt":"在Ubuntu 系统上执行如下命令 dd if=/img.iso of=/dev/mydevice bs=10M count=100000","text":"在Ubuntu 系统上执行如下命令 dd if=/img.iso of=/dev/mydevice bs=10M count=100000 有的时候，可能会非常耗时，这个时候，如果让dd命令输出执行进度信息，会非常有用。 重新打开一个Shell，然后执行如下命令即可每秒输出一次进度信息 watch -n 1 pkill -USR1 -x dd","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yigekaifa.com/tags/Linux/"},{"name":"cmd","slug":"cmd","permalink":"https://yigekaifa.com/tags/cmd/"}]},{"title":"自带清除内容功能的EditText","slug":"edittext-with-clear-icon","date":"2020-03-10T18:23:58.000Z","updated":"2020-03-10T19:34:08.799Z","comments":true,"path":"edittext-with-clear-icon/","link":"","permalink":"https://yigekaifa.com/edittext-with-clear-icon/","excerpt":"出发需求： 减少手写清除EditText内容的代码 xml里面写的话，点击清除按钮会失去焦点，然后软键盘消失，需要重复点击输入框才可以继续输入","text":"出发需求： 减少手写清除EditText内容的代码 xml里面写的话，点击清除按钮会失去焦点，然后软键盘消失，需要重复点击输入框才可以继续输入 public class ClearEditText extends AppCompatEditText implements View.OnFocusChangeListener, View.OnTouchListener, TextWatcher { private Drawable mClearTextIcon; private OnFocusChangeListener mOnFocusChangeListener; private OnTouchListener mOnTouchListener; private boolean isShowClearIcon; public ClearEditText(Context context) { super(context); init(context, null); } public ClearEditText(Context context, AttributeSet attrs) { super(context, attrs); init(context, attrs); } public ClearEditText(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context, attrs); } private void init(Context context, AttributeSet attrs) { mClearTextIcon = getCompoundDrawables()[2]; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ClearEditText); isShowClearIcon = typedArray.getBoolean(R.styleable.ClearEditText_isShowClearIcon, true); if (mClearTextIcon == null) { final Drawable drawable = ContextCompat.getDrawable(context, R.mipmap.icon_clear_text); final Drawable wrapDrawable = DrawableCompat.wrap(drawable); DrawableCompat.setTint(wrapDrawable, getCurrentHintTextColor()); mClearTextIcon = wrapDrawable; } mClearTextIcon.setBounds(0, 0, mClearTextIcon.getIntrinsicHeight(), mClearTextIcon.getIntrinsicHeight()); setClearIconVisible(false); super.setOnFocusChangeListener(this); super.setOnTouchListener(this); addTextChangedListener(this); } public void setmOnFocusChangeListener(OnFocusChangeListener mOnFocusChangeListener) { this.mOnFocusChangeListener = mOnFocusChangeListener; } public void setmOnTouchListener(OnTouchListener mOnTouchListener) { this.mOnTouchListener = mOnTouchListener; } private void setClearIconVisible(boolean visible) { mClearTextIcon.setVisible(visible &amp;&amp; isShowClearIcon, false); final Drawable[] compoundDrawables = getCompoundDrawables(); setCompoundDrawables( compoundDrawables[0], compoundDrawables[1], visible ? mClearTextIcon : null, compoundDrawables[3]); } @Override public void onFocusChange(View v, boolean hasFocus) { if (hasFocus) { setClearIconVisible(getText().length() &gt; 0); } else { setClearIconVisible(false); } if (mOnFocusChangeListener != null) { mOnFocusChangeListener.onFocusChange(v, hasFocus); } } @Override public boolean onTouch(View v, MotionEvent motionEvent) { int x = (int) motionEvent.getX(); if (mClearTextIcon.isVisible() &amp;&amp; x &gt; getWidth() - getPaddingRight() - mClearTextIcon.getIntrinsicWidth()) { if (motionEvent.getAction() == motionEvent.ACTION_UP) { setError(null); setText(&quot;&quot;); } return true; } return (mOnTouchListener != null &amp;&amp; mOnTouchListener.onTouch(v, motionEvent)); } public void isShowClearIcon(boolean isShowClearIcon) { this.isShowClearIcon = isShowClearIcon; setClearIconVisible(getText().length() &gt; 0); } @Override public void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) { if (isFocused()) { setClearIconVisible(text.length() &gt; 0); } } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void afterTextChanged(Editable s) { }} attrs： ```xml &lt;declare-styleable name=&quot;ClearEditText&quot;&gt; &lt;!--是否需要展示清除按钮--&gt; &lt;attr name=&quot;isShowClearIcon&quot; format=&quot;boolean&quot;/&gt; &lt;/declare-styleable&gt;使用 &lt;xxx.ClearEditText&gt; &lt;!--some parms here--&gt; ... &lt;!--set is show the icon here--&gt; app:isShowClearIcon = &quot;true&quot; &lt;/ClearEditText&gt; 或者在java代码中: clearTextView.isShowClearIcon(true);","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Edittext","slug":"Edittext","permalink":"https://yigekaifa.com/tags/Edittext/"},{"name":"Custom","slug":"Custom","permalink":"https://yigekaifa.com/tags/Custom/"}]},{"title":"监听布局内所有的EditText","slug":"listen-all-edittext-in-your-layout","date":"2020-03-10T15:49:23.000Z","updated":"2020-03-10T18:15:58.298Z","comments":true,"path":"listen-all-edittext-in-your-layout/","link":"","permalink":"https://yigekaifa.com/listen-all-edittext-in-your-layout/","excerpt":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步的控件，你可以试试下面这个控件。","text":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步的控件，你可以试试下面这个控件。 1. 获取子view编历布局，看当前布局有几个EditText,然后去监听拿到focus的view 获取子view的方式： // 遍历viewGroup public int traverseViewGroup(View view) { int viewCount = 0; if (null == view) { return 0; } if (view instanceof ViewGroup) { //遍历ViewGroup,是子view加1，是ViewGroup递归调用 for (int i = 0; i &lt; ((ViewGroup) view).getChildCount(); i++) { View child = ((ViewGroup) view).getChildAt(i); if (child instanceof ViewGroup) { viewCount += traverseViewGroup(((ViewGroup) view).getChildAt(i)); } else { viewCount++; } } } else { viewCount++; } return viewCount; } 非递归方法获取子view： // 遍历viewGroup public int traverseViewGroup(View view) { int viewCount = 0; if (null == view) { return 0; } if (view instanceof ViewGroup) { ViewGroup viewGroup = (ViewGroup) view; LinkedList&lt;ViewGroup&gt; linkedList = new LinkedList&lt;&gt;(); linkedList.add(viewGroup); while (!linkedList.isEmpty()) { //removeFirst()删除第一个元素，并返回该元素 ViewGroup current = linkedList.removeFirst(); viewCount++; //遍历linkedList中第一个viewGroup中的子view for (int i = 0; i &lt; current.getChildCount(); i++) { if (current.getChildAt(i) instanceof ViewGroup) { linkedList.addLast((ViewGroup) current.getChildAt(i)); } else { viewCount++; } } } } else { viewCount++; } return viewCount; } 获取到子view的时候，你需要判断这个子view是不是EditText，方法有两种： v.getClassName() == &quot;EditText&quot; v instanceof Button 2. 拿到子view之后：方法1. 拿到子view之后，不需要每个都去监听（当然你也可以这么做），另外一种，判断在viewgroup中哪个子view获取到了焦点，然后给他添加监听，其他的移除监听。 然后给设置的按钮去设置enable 方法2. LiveData监听数据变化，但是和上面的方式换汤不换药，代码量更多了一点。LiveData的具体使用可以参考： https://developer.android.google.cn/reference/android/arch/lifecycle/LiveData 需要完成的内容： 添加例外的参数，例如非必填的Edittext","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Edittext","slug":"Edittext","permalink":"https://yigekaifa.com/tags/Edittext/"},{"name":"ViewGroup","slug":"ViewGroup","permalink":"https://yigekaifa.com/tags/ViewGroup/"},{"name":"CustomView","slug":"CustomView","permalink":"https://yigekaifa.com/tags/CustomView/"}]},{"title":"startWithPop()出现两个Fragment都退出的情况","slug":"startwithpop-close-both-fragment","date":"2020-03-10T15:37:18.000Z","updated":"2020-03-10T19:34:18.671Z","comments":true,"path":"startwithpop-close-both-fragment/","link":"","permalink":"https://yigekaifa.com/startwithpop-close-both-fragment/","excerpt":"有时候startWithPop()会出现两个Fragment都出栈的情况，一般当前fragment是RootView的时候会出现这个情况。","text":"有时候startWithPop()会出现两个Fragment都出栈的情况，一般当前fragment是RootView的时候会出现这个情况。 解决方法： ((BaseFragment) getParentFragment()).start(toFragment); 或者 popTo(A.class,true,new Runnable(){ @Override public void run() { start(B); } },getFragmentAnimator().getPopExit()); // getFragmentAnimator().getPopExit() 代表popTo时的动画","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"startWithPop","slug":"startWithPop","permalink":"https://yigekaifa.com/tags/startWithPop/"},{"name":"Fragment","slug":"Fragment","permalink":"https://yigekaifa.com/tags/Fragment/"}]},{"title":"TabLayout的简单修改","slug":"some-changes-for-tablayout","date":"2020-03-10T15:11:19.000Z","updated":"2020-03-10T15:13:14.895Z","comments":true,"path":"some-changes-for-tablayout/","link":"","permalink":"https://yigekaifa.com/some-changes-for-tablayout/","excerpt":"设计稿上的tab布局我用了design库的tablayout，根据设计上的图来看，选中的tab要是粗体，下方横线等宽于字体。","text":"设计稿上的tab布局我用了design库的tablayout，根据设计上的图来看，选中的tab要是粗体，下方横线等宽于字体。 问题1：TabLayout无法控制当前选中的行的字体解决方案：setCustomView() 。 首先写一个方法，用来返回每个tab的view： public View getTabView(int position, String title) { View view = LayoutInflater.from(getContext()).inflate(R.layout.tab_item, null); TextView txt_title = (TextView) view.findViewById(R.id.textView); txt_title.setText(title); return view; } 然后把view设置到tablayout中： tabLayout.getTabAt(0).setCustomView(getTabView(0, &quot;全部&quot;)); 然后去选择控制tablayout的标签的样式，我是新建了一个OnTabSelectedListener，然后再里面进行设置的 OnTabSelectedListener onTabSelectedListener = new TabLayout.OnTabSelectedListener() { @Override public void onTabSelected(TabLayout.Tab tab) { // 选中的tab设置为粗体 TextView textView = tabLayout.getTabAt(tab.getPosition()).getCustomView().findViewById(R.id.textView); textView.setTypeface(null, Typeface.BOLD); viewPager.setCurrentItem(tab.getPosition()); } @Override public void onTabUnselected(TabLayout.Tab tab) { // 未选中的tab设置为正常 TextView textView = tabLayout.getTabAt(tab.getPosition()).getCustomView().findViewById(R.id.textView); textView.setTypeface(null, Typeface.NORMAL); } @Override public void onTabReselected(TabLayout.Tab tab) { } }; 但是，设置好之后出现了新的问题： 问题2：下面Indicator宽度始终为最宽的宽度即使你设置了app:tabIndicatorFullWidth=&quot;true&quot;，因为tabIndicatorFullWidth是根据默认布局的文字宽度来设置的，我们自定义布局之后，系统无法获取到文字大小和长度，所以就会设置成最宽的宽度。 我的解决方法： public void reflex(final TabLayout tabLayout) { tabLayout.post(new Runnable() { @Override public void run() { try { LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0); for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) { View tabView = mTabStrip.getChildAt(i); Field mTextViewField = tabView.getClass().getDeclaredField(&quot;textView&quot;); mTextViewField.setAccessible(true); TextView mTextView = (TextView) mTextViewField.get(tabView); tabView.setPadding(0, 0, 0, 0); int width = 0; width = mTextView.getWidth(); if (width == 0) { mTextView.measure(0, 0); width = mTextView.getMeasuredWidth(); } LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams(); params.width = width; WindowManager wm1 = ((Activity) getContext()).getWindowManager(); int width1 = wm1.getDefaultDisplay().getWidth(); LogUtils.d(&quot;&quot; + width1 / tabLayout.getTabCount() + &quot;=============&quot; + mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)); params.leftMargin = (width1 / tabLayout.getTabCount() - mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)) / 2; params.rightMargin = (width1 / tabLayout.getTabCount() - mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)) / 2; tabView.setLayoutParams(params); tabView.invalidate(); } } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } }); } public static int dip2px(Context context, float dpValue) { float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); } reflex(tabLayout);调用在所有getTabAt方法之后即可解决这个，但是还有点小问题，tab大小被设置成了文字宽度…这个问题暂时保留，下次解决。另外有几个小问题 去掉tab的水波纹效果，无论是support还是AdnroidX，都用app:tabRippleColor=&quot;@android:color/transparent&quot;，app:tabBackground=&quot;@android:color/transparent&quot;即使在support下也无效","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"TabLayout","slug":"TabLayout","permalink":"https://yigekaifa.com/tags/TabLayout/"},{"name":"widget","slug":"widget","permalink":"https://yigekaifa.com/tags/widget/"},{"name":"custom","slug":"custom","permalink":"https://yigekaifa.com/tags/custom/"}]},{"title":"Android中几种定位方式的粗解","slug":"some-way-to-get-location","date":"2020-03-10T14:46:16.000Z","updated":"2020-03-10T15:00:31.759Z","comments":true,"path":"some-way-to-get-location/","link":"","permalink":"https://yigekaifa.com/some-way-to-get-location/","excerpt":"之前朋友问我Tiktok为什么禁用了定位，开启了全局代理，还是可以获取到位置。当时想法只有一个：基站定位。我让他在设置里关掉移动服务（关闭手机卡）之后，确实可以正常使用了。 这里简单说一下Android中集中定位方式。","text":"之前朋友问我Tiktok为什么禁用了定位，开启了全局代理，还是可以获取到位置。当时想法只有一个：基站定位。我让他在设置里关掉移动服务（关闭手机卡）之后，确实可以正常使用了。 这里简单说一下Android中集中定位方式。 这里是在Android10添加的新权限，在后台获取位置：https://developer.android.com/reference/android/Manifest.permission.html#ACCESS_BACKGROUND_LOCATION 1. GPS权限（注意版本变化）： &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 具体定位代码 var locManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager var loc = locManager.getLastKnownLocation(LocationManager.GPS_PROVIDER) if(loc != null){ Log.e(&quot;gpslocation&quot;, loc.toString()) toast(loc.toString()) } locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0F, object : LocationListener{ override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) { } override fun onProviderEnabled(provider: String?) { } override fun onProviderDisabled(provider: String?) { } override fun onLocationChanged(location: Location?) { Log.e(&quot;gpslocation&quot;, location.toString()) toast(location.toString()) } }) 2. Network获取位置与GPS定位相同，代码都一样。只是申请权限不同。并且在室内时，GPS需要一定时间来定位，而Network在网络状况不好时不可用。 3. IPAPP通过对当前IP的分析，可以得到你大致的位置。一般不采用这种方案，IP太容易被伪装。 4. WiFi（WLAN）定位需要权限： &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; 这个也比较简单，就是过程就是拿到当前的WiFi信息，然后通过mac地址（BSSID）进行查询。具体查询的接口可以去聚合数据搜索一下，这里不再多说。 5. 基站定位这个要稍微说一下。在你关闭了所有定位传感器之后，如果你的手机还是处于有服务的状态下，就可以进行大概定位。通过TelephonyManager获取当前手机信号的基站信息。可以定位到大概区以下的位置。 MCC，Mobile Country Code，移动国家代码（中国的为460） MNC，Mobile Network Code，移动网络号码（中国移动为00，中国联通为01） LAC，Location Area Code，位置区域码 CID，Cell Identity，基站编号，是个16位的数据（范围是0到65535）看似类型繁多，但是实际用起来用处不是很多。建议大家还是用第三方定位库吧，简单精准还好用。 参考文章 https://developer.android.com/guide/topics/location/strategies","categories":[],"tags":[]}]}
{"meta":{"title":"一个开发","subtitle":null,"description":null,"author":"一个开发","url":"https://yigekaifa.com","root":"/"},"pages":[{"title":"","date":"2020-11-03T09:31:59.949Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"baidu_verify_LaFxvJnZ2o.html","permalink":"https://yigekaifa.com/baidu_verify_LaFxvJnZ2o.html","excerpt":"","text":"LaFxvJnZ2o"},{"title":"关于","date":"2020-03-10T14:43:04.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"about/index.html","permalink":"https://yigekaifa.com/about/index.html","excerpt":"","text":"一个开发， 把之前的文章都删除了，重新开始写。 所有文章除了特殊说明，都保留权限。如果想转发请联系 yigekaifa@gmail.com"},{"title":"分类","date":"2020-03-10T17:23:57.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"categories/index.html","permalink":"https://yigekaifa.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-10T17:22:20.000Z","updated":"2020-11-03T09:31:59.953Z","comments":true,"path":"tags/index.html","permalink":"https://yigekaifa.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git-glf","slug":"git-glf","date":"2020-11-03T09:37:57.000Z","updated":"2020-11-03T09:55:42.437Z","comments":true,"path":"git-glf/","link":"","permalink":"https://yigekaifa.com/git-glf/","excerpt":"问题出现在开发中，一般会有这样的情况，我们需要给同事发一个文件的静态下载地址。通常的选择我们公司都会有自己的samba服务器，但是个别情况下我们会使用git上传后发给对方。 如果你的文件过大，系统会报错提示：","text":"问题出现在开发中，一般会有这样的情况，我们需要给同事发一个文件的静态下载地址。通常的选择我们公司都会有自己的samba服务器，但是个别情况下我们会使用git上传后发给对方。 如果你的文件过大，系统会报错提示： fatal: The remote end hung up unexpectedly 大概意思就是说服务器断开，基本上都是因为服务器或git的限制，不允许传输过大的文件。这里有两种解决方法提供给大家 解决方法方法1：设置本地限制找到你的文档下.git文件夹，打开config文件 加入 [http]postBuffer &#x3D; 524288000 然后暴力push… ###方法2：开启git大文件支持插件 git-lfs 具体你可以查看git-lfs官网：https://git-lfs.github.com/ 或者跟着下面的步骤进行操作： 1.安装git-lfsgit lfs install 2.修改.gitattributes 文件，添加你需要支持的大文件例如你需要添加mp4文件，那么你需要在git目录下输入下面的命令 $ git lfs track &quot;*.mp4&quot;&gt; Adding path *.mp4 注意，这里的.gitattributes请提交到服务器，以免提交大文件后发生冲突。关联文件到你的仓库中 $ git add path&#x2F;to&#x2F;file.mp4 最后commit，push即可，一般在push的时候会有个上传进度。","categories":[],"tags":[]},{"title":"提高APP冷启动速度小结","slug":"cold-launch-faster","date":"2020-11-03T09:35:22.000Z","updated":"2020-11-03T09:55:36.701Z","comments":true,"path":"cold-launch-faster/","link":"","permalink":"https://yigekaifa.com/cold-launch-faster/","excerpt":"在系统完全结束APP的服务之后，冷启动APP仿佛像是生孩子一般难受，尤其是之前版本的支付宝。不过还是要点名表扬一下支付宝，在后续版本尤其是最新的10.0以及之后版本，大力优化了冷启动速度，虽然整个APP还是很重，主页内容还是很多，但是不得不说启动速度的优化还是很明显的。","text":"在系统完全结束APP的服务之后，冷启动APP仿佛像是生孩子一般难受，尤其是之前版本的支付宝。不过还是要点名表扬一下支付宝，在后续版本尤其是最新的10.0以及之后版本，大力优化了冷启动速度，虽然整个APP还是很重，主页内容还是很多，但是不得不说启动速度的优化还是很明显的。 下面是我工作中对APP启动速度优化的一些总结和看法： 一 / 去掉白屏背景首先，这个白屏背景是怎么来的呢？ Android上古时代，APP启动速度几乎只收到了硬件限制。后来，因为ios规定所有APP必须要有闪屏页，切闪屏页需要有图标相对应的内容。这样就使得在打开APP时，非线性动画配合貌似LOGO直接飞到屏幕中间的假效果看起来非常顺滑。Android虽然没有这个规定，但是两端毕竟应该统一。于是，就有了Android闪屏页，其实也就是默认主题的白屏的那一下，它实际上也是用来承接APP打开动效或者欢迎页面的（可以参考现版本的Twitter）。 这个不是我乱猜的，实际上Android是给了开发者打开APP时闪屏页显示内容的。这个白色背景就是你主题中windowBackground这个属性来控制的。具体方法: 首先我们需要定义一个XML文件，放置layer-list(图层列表/布局列表，具体使用可以百度)的内容。 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; android:opacity&#x3D;&quot;opaque&quot;&gt; &lt;!--给背景透明值，避免颜色闪烁，如果不设置，那么可能会有默认背景色和下面这个属性的一下闪烁交换的情况--&gt; &lt;item android:drawable&#x3D;&quot;@android:color&#x2F;black&quot; &#x2F;&gt; &lt;!--设置默认背景颜色--&gt; &lt;item&gt; &lt;bitmap android:gravity&#x3D;&quot;center&quot; android:src&#x3D;&quot;@mipmap&#x2F;logo&quot; &#x2F;&gt; &lt;&#x2F;item&gt; &lt;!--放置logo--&gt;&lt;&#x2F;layer-list&gt; 然后直接在你自定义的Theme中使用android:windowBackground去用这个布局即可。 再退一步说，你可能有自己更复杂的操作或者想法，要去掉这个页面使用自定义的页面，那么你只需要给你的Theme设置两个属性即可： &lt;item name&#x3D;&quot;android:windowIsTranslucent&quot;&gt;true&lt;&#x2F;item&gt;&lt;item name&#x3D;&quot;android:windowNoTitle&quot;&gt;true&lt;&#x2F;item&gt; 或者一行代码： name这两种方法我都是不排斥的并且我也有使用过，但是还是推荐按照官方的标准来进行开发。再退一步，请看标题，本文讲的是APP的启动速度优化…二 &#x2F; 及时结束onCreat()方法直到今天，在我们的APP中还存在大量把所有第三方组件初始化工作全部放在onCreat()中的情况。说真的，这个其实是 (官方唯一给出需要优化启动速度的切入点……)[https:&#x2F;&#x2F;developer.android.com&#x2F;topic&#x2F;performance&#x2F;vitals&#x2F;launch-time#internals]解决方法无非就三种&#96;&#96;&#96;异步加载，delay加载，按需加载 据我观察，京东APP几乎就用过了上面所有的方法…老版JD中，在初次打开APP时，是不会对一些插件进行加载的。然后在用户退出主页面之后，再次打开时会进行加载（这里要说明一下，如果APP中存在多进程，需要在主进程中加载）并且下载一些SO库（这个操作可以减小APP体积，但是你们要有自己的高速静态空间来保证后续访问）。但是新版京东APP中在首次打开就会delay一下，然后直接下载SO库、加载第三方插件。 虽然两种切换方式效果几乎没变，但是第一种情况导致的结果就是：我首次打开京东APP，登录页面没有QQ登录…需要退出重新打开才会显示… 实际上这几种方式不冲突，且可以共存。除了框架开发者要求或者自己使用需要的内容在Application的onCreat()中加载外，像是一些统计插件或者必须插件，建议在启动时进行异步加载；一些非必须功能插件或者登录之后使用功能的插件，建议delay一些时间再进行加载；一些非必须交互或者单页面插件（地图这些），建议按需加载。 三 / 假加速，‘但是肉眼可见的快了’有一次我负责基础框架部分，我因为失误把启动页指向首页。被组长发现后问我为什么这么写，我说我要再首页中启动闪屏页。又问为什么这么写，这和大家的开发习惯不同。 我说：在首页做任何操作之前，就在首页启动闪屏页。这样几乎没有增加任何时间，并且可以在打开闪屏页的时候加载首页的数据，这样可以减少用户打开首页的等待时间，这启动速度肉眼可见得快了。说完我当场试了一下，明显没有首页缓冲数据的那一下等待数据的白色页面时间…（说真的，我是临时编的）。 也就是说，最初是： 原来是：APP启动-&gt;启动闪屏页-&gt;闪屏页展示-&gt;闪屏页结束-&gt;首页-&gt;首页加载数据 改变成：APP启动-&gt;首页-&gt;启动闪屏页-&gt;闪屏页展示，同时首页加载数据-&gt;闪屏页结束但是我现在还会这么写…即使首页有缓存的情况下… 虽然这并不是启动加速，但是他就是加速了，我不管。 四 / MultiDex在5.0之下的问题U1S1，MultiDex就是个大坑，就是个为了打补丁，结果补丁上有个大坑的那种坑。5.0以上的系统不需要在意这个问题，也就是说如果你的安装要求版本&gt;20，那么这篇文章到这里就结束了。 因为5.0之后在安装APK时就会对MultiDex进行了优化，所以Multidex.install(this);几乎不会占用什么时间。 在5.0以下的系统中， MultiDex （(官方给出的MultiDex在5.0以下使用需要的设置)[https://developer.android.com/studio/build/multidex#mdex-pre-l]） 就是噩梦…尤其是在老版本或者低配置的设备中，Multidex.install(this);占用的时间远远超过了ANR的反应时间，直接导致了ANR，进不了闪屏页… 因为现在5.0以下的用户真不多了，我也不想写了。大致思路就是在启动之后hold住主线程，然后异步进程进行dexopt操作，待结束之后发标记回来继续启动APP就可以了。 这里推荐两个文章，写的都不错： https://blog.csdn.net/synaric/article/details/53540760 https://www.jianshu.com/p/1a7d8f449b77 除此之外，推荐阅读：https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd%20Android%E6%8B%86%E5%88%86%E4%B8%8E%E5%8A%A0%E8%BD%BDDex%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94","categories":[],"tags":[]},{"title":"免 ROOT 卸载 Android 预装软件的思路和实现","slug":"unroot-device-uninstall-prv-apps","date":"2020-08-02T04:51:05.000Z","updated":"2020-11-03T09:55:54.341Z","comments":true,"path":"unroot-device-uninstall-prv-apps/","link":"","permalink":"https://yigekaifa.com/unroot-device-uninstall-prv-apps/","excerpt":"苦于各种预装软件垃圾还不给卸载，这边文章被写了出来。（虽然后来我发现有很多） 首先，从 Android 4.2 开始，设备可以支持多用户，说到这里其实聪明的小朋友已经知道怎么实现了：","text":"苦于各种预装软件垃圾还不给卸载，这边文章被写了出来。（虽然后来我发现有很多） 首先，从 Android 4.2 开始，设备可以支持多用户，说到这里其实聪明的小朋友已经知道怎么实现了： 卸载当前用户的预装 APP 这种方法用 adb shell 的命令就可以实现，所以你需要提前准备 ADB 工具。具体只需要一行简单的命令： shell pm uninstall --user 0 应用包名```APP 的包名你需要到系统设置-&gt;软件设置-&gt;具体的软件页面去寻找，MIUI 是在右上角的叹号里(或者 MIUI11 之后的版本，你可以长安桌面图标，然后点击弹窗上的小叹号，再点击右上角的小叹号查看)。其他不同的系统不多说明。如果你需要安装回来，只需要使用&#96;&#96;&#96;adb shell pm install --user 0 应用包名 说一下： 实际上是卸载掉了，但是只是针对当前用户。如果你切换用户，需要卸载其他用户的 APP 。这个 APP 实际还存在你的prev-app(预装软件)区域内，但他不同于系统的停用操作，是真实卸载掉了的。 EMUI 和 MIUI的脚本下载地址 链接:https://pan.baidu.com/s/1gSwPkZLcGguIjaJmtENCHg 提取码:d43f 复制这段内容后打开百度网盘手机 App，操作更方便哦","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yigekaifa.com/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://yigekaifa.com/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"https://yigekaifa.com/tags/cnpm/"},{"name":"源地址","slug":"源地址","permalink":"https://yigekaifa.com/tags/%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"name":"淘宝源","slug":"淘宝源","permalink":"https://yigekaifa.com/tags/%E6%B7%98%E5%AE%9D%E6%BA%90/"}]},{"title":"两个方法解决git clone慢的问题","slug":"how-to-clone-git-faster","date":"2020-03-12T04:55:32.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"how-to-clone-git-faster/","link":"","permalink":"https://yigekaifa.com/how-to-clone-git-faster/","excerpt":"国内本来就没有git的服务器，所以访问超慢尤其是在个别运营商的加持下，速度更是慢到令人发指。所以我就总结了两个方法来解决这个问题。","text":"国内本来就没有git的服务器，所以访问超慢尤其是在个别运营商的加持下，速度更是慢到令人发指。所以我就总结了两个方法来解决这个问题。 方法一：使用gitee复制仓库，然后克隆gitee的仓库[推荐]在登陆gitee.com 之后，在右上角的加号里点击添加仓库，然后直接往下滑动。 在下面可以看到 然后点击导入已有仓库之后，在下面输入你需要克隆的仓库即可。 注意：这里如果系统提示你，当前已经存在克隆的仓库，为了避免已经存在的复制仓库有修改或者长时间未更新的情况，建议忽略提示。 优点：方便快捷，而且几十M的库克隆基本都是满速 问题：个别脚本内置的地址为github的地址，手动修改内容量太大 方法二：使用代理我们在打开代理之后，一般命令行工具是不走代理的，需要手动设置一下，这里我们用powershell做参考 # 注意，这里后面的1080为你的代理的端口，SS和SSR一般为1080,CLASH一般为7891，具体看个人设置$env:HTTPS_PROXY=\"http://127.0.0.1:1080\"$env:HTTP_PROXY=\"http://127.0.0.1:1080\" 如果不知道自己的代理端口是多少的话，windows下：设置-网络和Intetnet-代理-右面下方有端口显示","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yigekaifa.com/tags/git/"},{"name":"vpn","slug":"vpn","permalink":"https://yigekaifa.com/tags/vpn/"},{"name":"代理","slug":"代理","permalink":"https://yigekaifa.com/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"npm切换淘宝源","slug":"nodejs-change-source","date":"2020-03-12T04:51:05.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"nodejs-change-source/","link":"","permalink":"https://yigekaifa.com/nodejs-change-source/","excerpt":"全局配置切换到淘宝源 npm config set registry https://registry.npm.taobao.org","text":"全局配置切换到淘宝源 npm config set registry https://registry.npm.taobao.org 临时使用淘宝源 npm --registry https://registry.npm.taobao.org install node-red-contrib-composer@latest 全局配置切换到官方源 npm config set registry http://www.npmjs.org 检测是否切换到了淘宝源 npm info underscore 另外： 默认的npm下载地址：http://www.npmjs.org/淘宝npm镜像的地址：https://npm.taobao.org/你也可以使用CNPM：https://cnpmjs.org","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://yigekaifa.com/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://yigekaifa.com/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"https://yigekaifa.com/tags/cnpm/"},{"name":"源地址","slug":"源地址","permalink":"https://yigekaifa.com/tags/%E6%BA%90%E5%9C%B0%E5%9D%80/"},{"name":"淘宝源","slug":"淘宝源","permalink":"https://yigekaifa.com/tags/%E6%B7%98%E5%AE%9D%E6%BA%90/"}]},{"title":"PowerShell禁止执行脚本的解决方法","slug":"script-cant-run-on-powershell","date":"2020-03-10T18:26:23.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"script-cant-run-on-powershell/","link":"","permalink":"https://yigekaifa.com/script-cant-run-on-powershell/","excerpt":"如果出现类似下面的提示： 无法加载文件 ******.xxx，因为在此系统中禁止执行脚本。有关详细信息，请参阅 \"get-help about_signing\"。所在位置 行:1 字符: 17 解决方法：","text":"如果出现类似下面的提示： 无法加载文件 ******.xxx，因为在此系统中禁止执行脚本。有关详细信息，请参阅 \"get-help about_signing\"。所在位置 行:1 字符: 17 解决方法： 运行Get-ExecutionPolicy。如果返回Restricted，然后运行set-ExecutionPolicy RemoteSigned 然后就可以运行命令了。 另外如果还不能执行，例如你npm安装的一些命令不能运行，那么请你把C:\\Users\\用户名\\AppData\\Roaming\\npm添加到系统变量Path里面。","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://yigekaifa.com/tags/PowerShell/"},{"name":"Script","slug":"Script","permalink":"https://yigekaifa.com/tags/Script/"}]},{"title":"Linux下DD命令进度查看","slug":"dd-cmd-on-linux","date":"2020-03-10T18:25:06.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"dd-cmd-on-linux/","link":"","permalink":"https://yigekaifa.com/dd-cmd-on-linux/","excerpt":"在Ubuntu 系统上执行如下命令 dd if=/img.iso of=/dev/mydevice bs=10M count=100000","text":"在Ubuntu 系统上执行如下命令 dd if=/img.iso of=/dev/mydevice bs=10M count=100000 有的时候，可能会非常耗时，这个时候，如果让dd命令输出执行进度信息，会非常有用。 重新打开一个Shell，然后执行如下命令即可每秒输出一次进度信息 watch -n 1 pkill -USR1 -x dd","categories":[{"name":"Note","slug":"Note","permalink":"https://yigekaifa.com/categories/Note/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yigekaifa.com/tags/Linux/"},{"name":"cmd","slug":"cmd","permalink":"https://yigekaifa.com/tags/cmd/"}]},{"title":"自带清除内容功能的EditText","slug":"edittext-with-clear-icon","date":"2020-03-10T18:23:58.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"edittext-with-clear-icon/","link":"","permalink":"https://yigekaifa.com/edittext-with-clear-icon/","excerpt":"出发需求： 减少手写清除EditText内容的代码 xml里面写的话，点击清除按钮会失去焦点，然后软键盘消失，需要重复点击输入框才可以继续输入","text":"出发需求： 减少手写清除EditText内容的代码 xml里面写的话，点击清除按钮会失去焦点，然后软键盘消失，需要重复点击输入框才可以继续输入 public class ClearEditText extends AppCompatEditText implements View.OnFocusChangeListener, View.OnTouchListener, TextWatcher &#123; private Drawable mClearTextIcon; private OnFocusChangeListener mOnFocusChangeListener; private OnTouchListener mOnTouchListener; private boolean isShowClearIcon; public ClearEditText(Context context) &#123; super(context); init(context, null); &#125; public ClearEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public ClearEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; mClearTextIcon = getCompoundDrawables()[2]; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ClearEditText); isShowClearIcon = typedArray.getBoolean(R.styleable.ClearEditText_isShowClearIcon, true); if (mClearTextIcon == null) &#123; final Drawable drawable = ContextCompat.getDrawable(context, R.mipmap.icon_clear_text); final Drawable wrapDrawable = DrawableCompat.wrap(drawable); DrawableCompat.setTint(wrapDrawable, getCurrentHintTextColor()); mClearTextIcon = wrapDrawable; &#125; mClearTextIcon.setBounds(0, 0, mClearTextIcon.getIntrinsicHeight(), mClearTextIcon.getIntrinsicHeight()); setClearIconVisible(false); super.setOnFocusChangeListener(this); super.setOnTouchListener(this); addTextChangedListener(this); &#125; public void setmOnFocusChangeListener(OnFocusChangeListener mOnFocusChangeListener) &#123; this.mOnFocusChangeListener = mOnFocusChangeListener; &#125; public void setmOnTouchListener(OnTouchListener mOnTouchListener) &#123; this.mOnTouchListener = mOnTouchListener; &#125; private void setClearIconVisible(boolean visible) &#123; mClearTextIcon.setVisible(visible &amp;&amp; isShowClearIcon, false); final Drawable[] compoundDrawables = getCompoundDrawables(); setCompoundDrawables( compoundDrawables[0], compoundDrawables[1], visible ? mClearTextIcon : null, compoundDrawables[3]); &#125; @Override public void onFocusChange(View v, boolean hasFocus) &#123; if (hasFocus) &#123; setClearIconVisible(getText().length() &gt; 0); &#125; else &#123; setClearIconVisible(false); &#125; if (mOnFocusChangeListener != null) &#123; mOnFocusChangeListener.onFocusChange(v, hasFocus); &#125; &#125; @Override public boolean onTouch(View v, MotionEvent motionEvent) &#123; int x = (int) motionEvent.getX(); if (mClearTextIcon.isVisible() &amp;&amp; x &gt; getWidth() - getPaddingRight() - mClearTextIcon.getIntrinsicWidth()) &#123; if (motionEvent.getAction() == motionEvent.ACTION_UP) &#123; setError(null); setText(\"\"); &#125; return true; &#125; return (mOnTouchListener != null &amp;&amp; mOnTouchListener.onTouch(v, motionEvent)); &#125; public void isShowClearIcon(boolean isShowClearIcon) &#123; this.isShowClearIcon = isShowClearIcon; setClearIconVisible(getText().length() &gt; 0); &#125; @Override public void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; if (isFocused()) &#123; setClearIconVisible(text.length() &gt; 0); &#125; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125; attrs： &lt;declare-styleable name=\"ClearEditText\"&gt; &lt;!--是否需要展示清除按钮--&gt; &lt;attr name=\"isShowClearIcon\" format=\"boolean\"/&gt;&lt;/declare-styleable&gt; 使用 &lt;xxx.ClearEditText&gt; &lt;!--some parms here--&gt; ... &lt;!--set is show the icon here--&gt; app:isShowClearIcon = \"true\"&lt;/ClearEditText&gt; 或者在java代码中: clearTextView.isShowClearIcon(true);","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Edittext","slug":"Edittext","permalink":"https://yigekaifa.com/tags/Edittext/"},{"name":"Custom","slug":"Custom","permalink":"https://yigekaifa.com/tags/Custom/"}]},{"title":"监听布局内所有的EditText","slug":"listen-all-edittext-in-your-layout","date":"2020-03-10T15:49:23.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"listen-all-edittext-in-your-layout/","link":"","permalink":"https://yigekaifa.com/listen-all-edittext-in-your-layout/","excerpt":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步的控件，你可以试试下面这个控件。","text":"当出现布局内有N个输入框且需要同步监听，例如你需要监听用户输入所有内容之后才可以点击下一步的控件，你可以试试下面这个控件。 1. 获取子view编历布局，看当前布局有几个EditText,然后去监听拿到focus的view 获取子view的方式： // 遍历viewGroup public int traverseViewGroup(View view) &#123; int viewCount = 0; if (null == view) &#123; return 0; &#125; if (view instanceof ViewGroup) &#123; //遍历ViewGroup,是子view加1，是ViewGroup递归调用 for (int i = 0; i &lt; ((ViewGroup) view).getChildCount(); i++) &#123; View child = ((ViewGroup) view).getChildAt(i); if (child instanceof ViewGroup) &#123; viewCount += traverseViewGroup(((ViewGroup) view).getChildAt(i)); &#125; else &#123; viewCount++; &#125; &#125; &#125; else &#123; viewCount++; &#125; return viewCount; &#125; 非递归方法获取子view： // 遍历viewGroup public int traverseViewGroup(View view) &#123; int viewCount = 0; if (null == view) &#123; return 0; &#125; if (view instanceof ViewGroup) &#123; ViewGroup viewGroup = (ViewGroup) view; LinkedList&lt;ViewGroup&gt; linkedList = new LinkedList&lt;&gt;(); linkedList.add(viewGroup); while (!linkedList.isEmpty()) &#123; //removeFirst()删除第一个元素，并返回该元素 ViewGroup current = linkedList.removeFirst(); viewCount++; //遍历linkedList中第一个viewGroup中的子view for (int i = 0; i &lt; current.getChildCount(); i++) &#123; if (current.getChildAt(i) instanceof ViewGroup) &#123; linkedList.addLast((ViewGroup) current.getChildAt(i)); &#125; else &#123; viewCount++; &#125; &#125; &#125; &#125; else &#123; viewCount++; &#125; return viewCount; &#125; 获取到子view的时候，你需要判断这个子view是不是EditText，方法有两种： v.getClassName() == \"EditText\" v instanceof Button 2. 拿到子view之后：方法1. 拿到子view之后，不需要每个都去监听（当然你也可以这么做），另外一种，判断在viewgroup中哪个子view获取到了焦点，然后给他添加监听，其他的移除监听。 然后给设置的按钮去设置enable 方法2. LiveData监听数据变化，但是和上面的方式换汤不换药，代码量更多了一点。LiveData的具体使用可以参考： https://developer.android.google.cn/reference/android/arch/lifecycle/LiveData 需要完成的内容： 添加例外的参数，例如非必填的Edittext","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Edittext","slug":"Edittext","permalink":"https://yigekaifa.com/tags/Edittext/"},{"name":"ViewGroup","slug":"ViewGroup","permalink":"https://yigekaifa.com/tags/ViewGroup/"},{"name":"CustomView","slug":"CustomView","permalink":"https://yigekaifa.com/tags/CustomView/"}]},{"title":"startWithPop()出现两个Fragment都退出的情况","slug":"startwithpop-close-both-fragment","date":"2020-03-10T15:37:18.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"startwithpop-close-both-fragment/","link":"","permalink":"https://yigekaifa.com/startwithpop-close-both-fragment/","excerpt":"有时候startWithPop()会出现两个Fragment都出栈的情况，一般当前fragment是RootView的时候会出现这个情况。","text":"有时候startWithPop()会出现两个Fragment都出栈的情况，一般当前fragment是RootView的时候会出现这个情况。 解决方法： ((BaseFragment) getParentFragment()).start(toFragment); 或者 popTo(A.class,true,new Runnable()&#123; @Override public void run() &#123; start(B); &#125;&#125;,getFragmentAnimator().getPopExit()); // getFragmentAnimator().getPopExit() 代表popTo时的动画","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"startWithPop","slug":"startWithPop","permalink":"https://yigekaifa.com/tags/startWithPop/"},{"name":"Fragment","slug":"Fragment","permalink":"https://yigekaifa.com/tags/Fragment/"}]},{"title":"TabLayout的简单修改","slug":"some-changes-for-tablayout","date":"2020-03-10T15:11:19.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"some-changes-for-tablayout/","link":"","permalink":"https://yigekaifa.com/some-changes-for-tablayout/","excerpt":"设计稿上的tab布局我用了design库的tablayout，根据设计上的图来看，选中的tab要是粗体，下方横线等宽于字体。","text":"设计稿上的tab布局我用了design库的tablayout，根据设计上的图来看，选中的tab要是粗体，下方横线等宽于字体。 问题1：TabLayout无法控制当前选中的行的字体解决方案：setCustomView() 。 首先写一个方法，用来返回每个tab的view： public View getTabView(int position, String title) &#123; View view = LayoutInflater.from(getContext()).inflate(R.layout.tab_item, null); TextView txt_title = (TextView) view.findViewById(R.id.textView); txt_title.setText(title); return view;&#125; 然后把view设置到tablayout中： tabLayout.getTabAt(0).setCustomView(getTabView(0, \"全部\")); 然后去选择控制tablayout的标签的样式，我是新建了一个OnTabSelectedListener，然后再里面进行设置的 OnTabSelectedListener onTabSelectedListener = new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // 选中的tab设置为粗体 TextView textView = tabLayout.getTabAt(tab.getPosition()).getCustomView().findViewById(R.id.textView); textView.setTypeface(null, Typeface.BOLD); viewPager.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; // 未选中的tab设置为正常 TextView textView = tabLayout.getTabAt(tab.getPosition()).getCustomView().findViewById(R.id.textView); textView.setTypeface(null, Typeface.NORMAL); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;; 但是，设置好之后出现了新的问题： 问题2：下面Indicator宽度始终为最宽的宽度即使你设置了app:tabIndicatorFullWidth=&quot;true&quot;，因为tabIndicatorFullWidth是根据默认布局的文字宽度来设置的，我们自定义布局之后，系统无法获取到文字大小和长度，所以就会设置成最宽的宽度。 我的解决方法： public void reflex(final TabLayout tabLayout) &#123; tabLayout.post(new Runnable() &#123; @Override public void run() &#123; try &#123; LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0); for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123; View tabView = mTabStrip.getChildAt(i); Field mTextViewField = tabView.getClass().getDeclaredField(\"textView\"); mTextViewField.setAccessible(true); TextView mTextView = (TextView) mTextViewField.get(tabView); tabView.setPadding(0, 0, 0, 0); int width = 0; width = mTextView.getWidth(); if (width == 0) &#123; mTextView.measure(0, 0); width = mTextView.getMeasuredWidth(); &#125; LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams(); params.width = width; WindowManager wm1 = ((Activity) getContext()).getWindowManager(); int width1 = wm1.getDefaultDisplay().getWidth(); LogUtils.d(\"\" + width1 / tabLayout.getTabCount() + \"=============\" + mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)); params.leftMargin = (width1 / tabLayout.getTabCount() - mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)) / 2; params.rightMargin = (width1 / tabLayout.getTabCount() - mTextView.getText().length() * dip2px(tabLayout.getContext(), 15)) / 2; tabView.setLayoutParams(params); tabView.invalidate(); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; public static int dip2px(Context context, float dpValue) &#123; float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; reflex(tabLayout);调用在所有getTabAt方法之后即可解决这个，但是还有点小问题，tab大小被设置成了文字宽度…这个问题暂时保留，下次解决。另外有几个小问题 去掉tab的水波纹效果，无论是support还是AdnroidX，都用app:tabRippleColor=&quot;@android:color/transparent&quot;，app:tabBackground=&quot;@android:color/transparent&quot;即使在support下也无效","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"TabLayout","slug":"TabLayout","permalink":"https://yigekaifa.com/tags/TabLayout/"},{"name":"widget","slug":"widget","permalink":"https://yigekaifa.com/tags/widget/"},{"name":"custom","slug":"custom","permalink":"https://yigekaifa.com/tags/custom/"}]},{"title":"Android中几种定位方式的粗解","slug":"some-way-to-get-location","date":"2020-03-10T14:46:16.000Z","updated":"2020-11-03T09:31:59.949Z","comments":true,"path":"some-way-to-get-location/","link":"","permalink":"https://yigekaifa.com/some-way-to-get-location/","excerpt":"之前朋友问我Tiktok为什么禁用了定位，开启了全局代理，还是可以获取到位置。当时想法只有一个：基站定位。我让他在设置里关掉移动服务（关闭手机卡）之后，确实可以正常使用了。 这里简单说一下Android中集中定位方式。","text":"之前朋友问我Tiktok为什么禁用了定位，开启了全局代理，还是可以获取到位置。当时想法只有一个：基站定位。我让他在设置里关掉移动服务（关闭手机卡）之后，确实可以正常使用了。 这里简单说一下Android中集中定位方式。 这里是在Android10添加的新权限，在后台获取位置：https://developer.android.com/reference/android/Manifest.permission.html#ACCESS_BACKGROUND_LOCATION 1. GPS权限（注意版本变化）： &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt; 具体定位代码 var locManager = getSystemService(Context.LOCATION_SERVICE) as LocationManagervar loc = locManager.getLastKnownLocation(LocationManager.GPS_PROVIDER)if(loc != null)&#123; Log.e(\"gpslocation\", loc.toString()) toast(loc.toString())&#125;locManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0F, object : LocationListener&#123; override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) &#123; &#125; override fun onProviderEnabled(provider: String?) &#123; &#125; override fun onProviderDisabled(provider: String?) &#123; &#125; override fun onLocationChanged(location: Location?) &#123; Log.e(\"gpslocation\", location.toString()) toast(location.toString()) &#125;&#125;) 2. Network获取位置与GPS定位相同，代码都一样。只是申请权限不同。并且在室内时，GPS需要一定时间来定位，而Network在网络状况不好时不可用。 3. IPAPP通过对当前IP的分析，可以得到你大致的位置。一般不采用这种方案，IP太容易被伪装。 4. WiFi（WLAN）定位需要权限： &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; 这个也比较简单，就是过程就是拿到当前的WiFi信息，然后通过mac地址（BSSID）进行查询。具体查询的接口可以去聚合数据搜索一下，这里不再多说。 5. 基站定位这个要稍微说一下。在你关闭了所有定位传感器之后，如果你的手机还是处于有服务的状态下，就可以进行大概定位。通过TelephonyManager获取当前手机信号的基站信息。可以定位到大概区以下的位置。 MCC，Mobile Country Code，移动国家代码（中国的为460）MNC，Mobile Network Code，移动网络号码（中国移动为00，中国联通为01）LAC，Location Area Code，位置区域码CID，Cell Identity，基站编号，是个16位的数据（范围是0到65535） 看似类型繁多，但是实际用起来用处不是很多。建议大家还是用第三方定位库吧，简单精准还好用。 参考文章 https://developer.android.com/guide/topics/location/strategies","categories":[{"name":"Dev","slug":"Dev","permalink":"https://yigekaifa.com/categories/Dev/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yigekaifa.com/tags/Android/"},{"name":"Location","slug":"Location","permalink":"https://yigekaifa.com/tags/Location/"},{"name":"定位","slug":"定位","permalink":"https://yigekaifa.com/tags/%E5%AE%9A%E4%BD%8D/"}]}]}